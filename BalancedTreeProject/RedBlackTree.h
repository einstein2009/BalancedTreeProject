/***********************************************************
*                                                          *
*  Authors:       Rodel Aragon, Colby Abrahamoff,          *
*                 Christsandra Broderick, Chandler Snoddy  *
*                 Nicholas Ackors, Stephen Hall            *
*  Course:        CS322 Data Structure and Algorithms II   *
*  Assignment:    Module 6, Written Assignment             *
*  Program:       2-3-4 Tree and Red-Black Tree       	   *
*  Description:   Creates a 2-3-4 Tree with with random    *
*                 integers, then converts the tree to a    *
*                 red-black tree.                          *
*  Input:         Takes as input 100 random int values     *
*                 generated by the rand() function         *
*  Output:        Several lines displaying the values      *
*                 contained within the 2-3-4 tree and the  *
*                 red-black tree. Output is displayed to   *
*                 discern both trees as a 2-3-4 tree and   *
*                 a red-black tree.                        *
*  Created:       12/1/2017                                *
*                                                          *
***********************************************************/


#include "BinaryNode.h"
using namespace std;
enum Color { RED, BLACK };

template <class ItemType>
class RedBlackTree
{
private:
	Node *root;
	void rotateLeft(Node *&, Node *&);
	void rotateRight(Node *&, Node *&);
	void fixViolations(Node *&, Node *&)

public:
	RedBlackTree() { root = NULL; }
	void insert(const int &n);
	void inorder();
	void levelOrder();
	void fixViolations(Node *&root, Node *&point);
	void Display(Node *root);
};


//The following might need to be added to the main code since it deals with rotating the nodes left and right.

void RedBlackTree::rotateLeft(Node *&root, Node *point)
{
	Node *point_right = point->right;
	point->right = point_right->left;

	if (point->right != NULL)
		point->right->parent = point;
	point_right->parent = point->parent;

	if (point->parent == NULL)
		root = point_right;
	else
		if (point == point->parent->left)
			point->parent->left = point_right;

		else
			point - parent->right = point_right;

	point_right->left = point;
	point->parent = point_right;
}

void RedBlackTree::rotateRight(Node *&root, Node *&point)
{
	Node *point_left = point->left;

	point->left = point_left->right;

	if (point->left != NULL)
		point->left->parent = point;

	point_left->parent = point->parent;

	if (point->parent == NULL)
		root = point_left;

	else 
		if (point == point->parent->left)
			point->parent->left = point_left;

	else
		point->parent->right = point_left;

	point_left->right = point;
	point->parent = point_left;
}

//This section involves detecting and fixing violations with the RedBlackTree. I think this also should be in the main.cpp file.

void RedBlackTree::fixViolations(Node *&root, Node *&point)
{
	Node *parent_point = NULL;
	Node *grandParent_point = NULL;
	//For this function, 'point' is considered the child.
	//Parent_point is the parent of the child.
	//grandParent_point is the grandparent of the child.
	//sibling_point is the sibling of the parent of the child.

	while ((point != root) && (point->color != BLACK) && (point->parent->color == RED))
	{
		parent_point = point->parent;
		grandParent_point = point->parent->parent;

		//Scenario 1: the parent of 'point' is the left child of the grandparent of 'point'.
		if (parent_point == grandParent_point->left)
		{
			//Since it's the sibling of the parent, they'd be on the same height.
			Node * sibling_point = grandParent_point->right;

			//Scenario 1A: If the sibling of the parent of the child is also red: The parent and the sibling need to be recolored black, and the grandparent needs to be recolored red.
			if (sibling_point != NULL && sibling_point->color == RED)
			{
				sibling_point->color = BLACK;
				parent_point->color = BLACK; 
				grandParent_point->color = RED; 
				point = grandParent_point;
				
			}

			else
			{
				//Scenario 1B: The point is the right child of the parent. Left rotate.
				if (point == parent_point->right)
				{ 
					rotateLeft(root, parent_point);
					point = parent_point;
					parent_point = point->parent;
				}

				//Scenario 1C: The point is the left child of the parent. Right rotate.
				rotateRight(root, grandParent_point);
				swap(parent_point->color , grandParent_point->color); //Googling on how to switch values gave me the 'swap' function, but it doesn't seem to work.
				point = parent_point;
			}

		}
		//Scenario 2: The parent of 'point' if the fight child of the grandparent of 'point'.
		else
		{
			Node * sibling_point = grandParent_point->right;

			//Scenario 2A: If the sibling of the parent of the child is also red: The parent and the sibling need to be recolored black, and the grandparent needs to be recolored red.
			if (sibling_point != NULL && sibling_point->color == RED)
			{
				sibling_point->color = BLACK;
				parent_point->color = BLACK;
				grandParent_point->color = RED;
				point = grandParent_point;

			}

			else
			{
				//Scenario 2B: The point is the left child of the parent. Right rotate.
				if (point == parent_point->right)
				{
					rotateRight(root, parent_point);
					point = parent_point;
					parent_point = point->parent;
				}

				//Scenario 2C: The point is the right child of the parent. Left rotate.
				rotateLeft(root, grandParent_point);
				swap(parent_point->color, grandParent_point->color); //Googling on how to switch values gave me the 'swap' function, but it doesn't seem to work.
				point = parent_point;
			}

		}

	}

}
